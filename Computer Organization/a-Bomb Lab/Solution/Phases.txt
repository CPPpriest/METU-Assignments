
phase 1
------- 
Your text is: Take the risk or lose the chance.


phase 2
-------
2 5 10 17 26 37


phase 3:
4 _ _ 








get long ( 0x555555403e00 + i1*4 )



(80 + i1*4) + 80

i1 > 1			
i2 = i1 + 3
i3 = i2 + 5
i4 = i3 + 7
...


Dump of assembler code for function phase_2:
   0x000055555540248b <+0>:	push   %rbp
   0x000055555540248c <+1>:	push   %rbx	
   0x000055555540248d <+2>:	sub    $0x28,%rsp	
   0x0000555555402491 <+6>:	mov    %fs:0x28,%rax
   0x000055555540249a <+15>:	mov    %rax,0x18(%rsp)
   0x000055555540249f <+20>:	xor    %eax,%eax
   0x00005555554024a1 <+22>:	mov    %rsp,%rsi
   0x00005555554024a4 <+25>:	call   0x555555402d60 <read_six_numbers>
   0x00005555554024a9 <+30>:	cmpl   $0x1,(%rsp)				// first input must be greater than 1
   0x00005555554024ad <+34>:	jle    0x5555554024b9 <phase_2+46>
   0x00005555554024af <+36>:	mov    %rsp,%rbp
   0x00005555554024b2 <+39>:	mov    $0x3,%ebx
   0x00005555554024b7 <+44>:	jmp    0x5555554024cc <phase_2+65>
=> 0x00005555554024b9 <+46>:	call   0x555555402d24 <explode_bomb>
   0x00005555554024be <+51>:	jmp    0x5555554024af <phase_2+36>
   0x00005555554024c0 <+53>:	add    $0x4,%rbp
   0x00005555554024c4 <+57>:	add    $0x2,%ebx				// increment by 2 : 3 + 2 + 2 ... 
   										until it is not equal to 13	 
   0x00005555554024c7 <+60>:	cmp    $0xd,%ebx
   0x00005555554024ca <+63>:	je     0x5555554024dd <phase_2+82>
   0x00005555554024cc <+65>:	mov    %ebx,%eax
   0x00005555554024ce <+67>:	add    0x0(%rbp),%eax
   0x00005555554024d1 <+70>:	cmp    %eax,0x4(%rbp)				// second input must be first_input+3
   0x00005555554024d4 <+73>:	je     0x5555554024c0 <phase_2+53>
   0x00005555554024d6 <+75>:	call   0x555555402d24 <explode_bomb>
   0x00005555554024db <+80>:	jmp    0x5555554024c0 <phase_2+53>
   0x00005555554024dd <+82>:	mov    0x18(%rsp),%rax
   0x00005555554024e2 <+87>:	xor    %fs:0x28,%rax
   0x00005555554024eb <+96>:	jne    0x5555554024f4 <phase_2+105>
   0x00005555554024ed <+98>:	add    $0x28,%rsp
   0x00005555554024f1 <+102>:	pop    %rbx
   0x00005555554024f2 <+103>:	pop    %rbp
   0x00005555554024f3 <+104>:	ret    
   0x00005555554024f4 <+105>:	call   0x555555401ff0 <__stack_chk_fail@plt>







2 -> 134
6 -> 113




Dump of assembler code for function phase_3:
   0x00005555554024f9 <+0>:	push   %rbx
   0x00005555554024fa <+1>:	sub    $0x20,%rsp
   0x00005555554024fe <+5>:	mov    %fs:0x28,%rax
   0x0000555555402507 <+14>:	mov    %rax,0x18(%rsp)
   0x000055555540250c <+19>:	xor    %eax,%eax
   0x000055555540250e <+21>:	lea    0x10(%rsp),%rcx
   0x0000555555402513 <+26>:	lea    0xc(%rsp),%rdx
   0x0000555555402518 <+31>:	lea    0x14(%rsp),%r8
   0x000055555540251d <+36>:	lea    0x1b86(%rip),%rsi        # 0x5555554040aa	// get "%d %d %d"
   0x0000555555402524 <+43>:	call   0x555555402090 <__isoc99_sscanf@plt>
   0x0000555555402529 <+48>:	cmp    $0x2,%eax	
   0x000055555540252c <+51>:	jle    0x555555402549 <phase_3+80>
   0x000055555540252e <+53>:	cmpl   $0x7,0xc(%rsp)					// i1 must be <= 7
   0x0000555555402533 <+58>:	ja     0x555555402557 <phase_3+94>			
=> 0x0000555555402535 <+60>:	mov    0xc(%rsp),%eax					
   0x0000555555402539 <+64>:	lea    0x18c0(%rip),%rdx        # 0x555555403e00
   0x0000555555402540 <+71>:	movslq (%rdx,%rax,4),%rax
   0x0000555555402544 <+75>:	add    %rdx,%rax
   0x0000555555402547 <+78>:	jmp    *%rax
   0x0000555555402549 <+80>:	call   0x555555402d24 <explode_bomb>
   0x000055555540254e <+85>:	jmp    0x55555540252e <phase_3+53>
   0x0000555555402550 <+87>:	mov    $0xfe,%ebx
   0x0000555555402555 <+92>:	jmp    0x55555540258b <phase_3+146>
   0x0000555555402557 <+94>:	call   0x555555402d24 <explode_bomb>
   0x000055555540255c <+99>:	mov    $0x0,%ebx
   0x0000555555402561 <+104>:	jmp    0x55555540258b <phase_3+146>
   0x0000555555402563 <+106>:	mov    $0x88,%ebx
   0x0000555555402568 <+111>:	jmp    0x55555540258b <phase_3+146>
   0x000055555540256a <+113>:	mov    $0x3b,%ebx
   0x000055555540256f <+118>:	jmp    0x55555540258b <phase_3+146>
   0x0000555555402571 <+120>:	mov    $0x1de,%ebx
   0x0000555555402576 <+125>:	jmp    0x55555540258b <phase_3+146>
   0x0000555555402578 <+127>:	mov    $0x36a,%ebx
   0x000055555540257d <+132>:	jmp    0x55555540258b <phase_3+146>
   0x000055555540257f <+134>:	mov    $0x2af,%ebx
   0x0000555555402584 <+139>:	jmp    0x55555540258b <phase_3+146>
   0x0000555555402586 <+141>:	mov    $0xbf,%ebx
   0x000055555540258b <+146>:	call   0x555555402d24 <explode_bomb>
   0x0000555555402590 <+151>:	mov    0x10(%rsp),%edx
   0x0000555555402594 <+155>:	mov    %ebx,%esi
   0x0000555555402596 <+157>:	mov    0x14(%rsp),%edi
   0x000055555540259a <+161>:	call   0x5555554029b1 <check_substraction_equal>
   0x000055555540259f <+166>:	test   %eax,%eax
   0x00005555554025a1 <+168>:	je     0x5555554025c0 <phase_3+199>
   0x00005555554025a3 <+170>:	mov    0x18(%rsp),%rax
   0x00005555554025a8 <+175>:	xor    %fs:0x28,%rax
   0x00005555554025b1 <+184>:	jne    0x5555554025c7 <phase_3+206>
   0x00005555554025b3 <+186>:	add    $0x20,%rsp
   0x00005555554025b7 <+190>:	pop    %rbx
   0x00005555554025b8 <+191>:	ret    
   0x00005555554025b9 <+192>:	mov    $0x344,%ebx
   0x00005555554025be <+197>:	jmp    0x555555402590 <phase_3+151>
   0x00005555554025c0 <+199>:	call   0x555555402d24 <explode_bomb>
   0x00005555554025c5 <+204>:	jmp    0x5555554025a3 <phase_3+170>
   0x00005555554025c7 <+206>:	call   0x555555401ff0 <__stack_chk_fail@plt>




